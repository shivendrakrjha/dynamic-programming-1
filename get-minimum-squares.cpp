/*
https://practice.geeksforgeeks.org/problems/get-minimum-squares/0/

Given a number N. You need to write a program to print the minimum number of squares of this number that sums to N. For Example: If N = 100 , N can be expressed as (10*10) and also as (5*5 + 5*5 + 5*5 + 5*5) but the output will be 1 as minimum number of square is 1 , i.e (10*10).

Input:
First line of input contains a single integer T, which denotes the number of test cases. Then T test cases follows. First line of each test case contains a single integer N.
Output:
For each test case print the minimum number of squares that sums to N.

Constraints:
1<=T<=100
1<=N<=104

Example:
Input:
3
100
6
25
Output:
1
3
1
*/

#include<bits/stdc++.h>
#include<iostream>
#define el "\n"
#define ll long long int
#define pb push_back
#define u_m unordered_map
#define u_s unordered_set
#define p_q priority_queue
using namespace std;

// this is just a variant of coin change problem
// where variants of coins are to be generated by ourself
// i.e. no's below N which are perfect squares ar the given coins
// https://practice.geeksforgeeks.org/problems/number-of-coins/0/

ll dp[10005];

ll change(vector<ll> &c, ll n, ll sum) {
	if (sum==0) return 0;
	if (sum<0) return INT_MAX;
	
	if (dp[sum]!=-1) return dp[sum];
	
	ll ans=INT_MAX;
	for (ll i=0; i<n; i++) {
		ll temp = change(c,n,sum-c[i]);
		if (temp!=INT_MAX && temp+1<ans)
			ans = temp+1;
	}
	return dp[sum]=ans;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	int t; cin>>t;
	while (t--) {
		ll n; cin>>n;
		vector<ll> c; c.reserve(10000);
		for (ll i=1; ; i++) {
			ll sq = i*i;
			c.pb(sq);
			if (sq>n) {
				c.pop_back();
				break;
			}
		}
		memset(dp, -1, sizeof(dp));
		cout << change(c, c.size(), n) << el;
	}
}